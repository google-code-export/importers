class PyFileImporter(importlib.abc.Finder, importlib.abc.PyLoader):

    """ABC for importing Python source files.

    Required methods to implement:

        * file_exists
        * get_data: inherited

    """

    def __init__(self, location):
        self.location = location

    def file_exists(self, path):
        """Return true if the file path exists, else false.

        Setting 'directory' to true means to check if the path exists and is a
        directory. Otherwise the default behavior is to perform a file check.

        """
        # XXX Make it __contains__() instead?
        # XXX Perhaps add an optional directory_exists() check explicitly for
        #     ImportWarning?

    def find_module(self, fullname, path=None):
        # XXX Use generic private method that takes valid types so as to reuse
        #     for source_path and bytecode_path.

    def source_path(self, fullname):
        # XXX Recode using generic method shared with find_module.
        tail_name = fullname.rpartition('.')[-1]
        # XXX Also look for packages
        for ext in (x[0] for x in imp.get_suffixes() if x[2] == imp.PY_SOURCE):
            path = os.path.join(self.location, tail_name + ext)
            if path:
                return path
        else:
            return None

    def is_package(self, fullname):
        path = self.get_filename(fullname)
        if os.path.splitext(os.path.basename(path))[0] == '__init__':
            return True
        else:
            return False


# XXX PyPycFileImporter: add path_mtime, impl source_mtime & bytecode_path


class ArchiveHook:

    """sys.path_hook ABC for archive files (e.g. zip files).
    
    Required methods:

        * open
        * finder
    
    """

    def __init__(self):
        """Initialize the internal cache of archives."""
        self._archives = {}

    def __del__(self):
        """Close all cached archives."""
        for archive in self._archives.values():
            try:
                archive.close()
            except Exception:
                pass

    def open(self, path):
        """Open the path for use, raising ValueError otherwise."""

    def finder(self, archive, archive_path, pkg_path):
        """Return a finder for the opened archive at the specified package
        path."""

    def __call__(self, path):
        # XXX Check cache
        # XXX Look for file
        # XXX If file found, see if proper format


class PathCache:

    """Caches path existence checks for other classes implementing
    file_exists().

    This can be useful for mitigating stat calls (or the equivalent) when they
    are expensive at the cost of dynamicism for the importer. The class allows
    for controlling whether successful and/or unsuccessful path checks should
    be cached. If Python code will be added and removed to the store the
    importer is working with then caching should be turned off to allow the
    importer to pick up on new code. If only new code will be added to the
    store (e.g. no new source but new bytecode is a possibility),
    then only caching successful file checks is desired. But if the importer is
    interacting with a read-only store then both successes and failures should
    be cached.

    By default the class caches successes and only caches failures if
    sys.dont_write_bytecode is true. This should give the best performance for
    expected semantics of an append-only store (e.g. no new source but new
    bytecode is possible).

    """

    def __init__(*args, cache_success=True,
                    cache_failure=sys.dont_write_bytecode, **kwargs):
        """Initialize the cache and record what should be cached."""
        super().__init__(*args, **kwargs)
        self.__cache_hits = hits
        self.__cache_misses = misses
        self.clear()

    def clear(self):
        """Clear the cache."""
        self.__path_cache = {}

    def file_exists(self, path):
        """Try to return the result from cache, else call the super class and
        cache the result (depending on settings)."""
        try:
            return self.__path_cache[path]
        except KeyError:
            exists = super().file_exists(path)
            if exists and self.__cache_hits:
                self.__path_cache[path] = True
            elif not exists and self.__cache_misses:
                self.__path_cache[path] = False

            return exists


class Sqlite3Hook(ArchiveHook):

    def open(self, path):
        # XXX

    def finder(self, cxn, db_path, pkg_path):
        return Sqlite3Importer(cxn, db_path, pkg_path)


class Sqlite3Importer(PyFileImporter):

    def __init__(self, cxn, db_path, pkg_path):
        super().__init__(os.path.join(db_path, pkg_path))
        self._cxn = cxn
        self._db_path = db_path

    def file_exists(self, path):
        # XXX

    def get_data(self, path):
        # XXX

    def source_mtime(self, fullname):
        # XXX

    def write_bytecode(self, fullname, data):
        # XXX
